import PDFDocument from 'pdfkit';
import { SeoAuditReport, SeoIssue } from './report-generator.service';

/**
 * Service for generating PDF reports from SEO audit data
 */
export class PdfGeneratorService {
  /**
   * Generate a PDF report from SEO audit data
   * 
   * @param report SEO audit report data
   * @returns Buffer containing the PDF data
   */
  async generatePdf(report: SeoAuditReport): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      try {
        // Create a document
        const doc = new PDFDocument({
          margin: 50,
          size: 'A4',
          info: {
            Title: `SEO Audit Report - ${report.target}`,
            Author: 'WordGen SEO Audit System',
            Subject: 'SEO Audit Report',
            Keywords: 'SEO, audit, website analysis'
          }
        });
        
        // Collect PDF chunks
        const chunks: Buffer[] = [];
        doc.on('data', (chunk) => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));
        doc.on('error', (err) => reject(err));
        
        // Add content to the PDF
        this.generateCoverPage(doc, report);
        doc.addPage();
        this.generateSummaryPage(doc, report);
        doc.addPage();
        this.generateIssuesPages(doc, report);
        doc.addPage();
        this.generatePerformancePage(doc, report);
        doc.addPage();
        this.generateContentPage(doc, report);
        
        // Finalize the PDF
        doc.end();
      } catch (error) {
        console.error('Error generating PDF:', error);
        reject(error);
      }
    });
  }
  
  /**
   * Generate the cover page of the report
   */
  private generateCoverPage(doc: PDFKit.PDFDocument, report: SeoAuditReport): void {
    // Add logo
    // doc.image('path-to-logo', 50, 45, { width: 150 });
    
    // Title
    doc.fontSize(30)
       .fillColor('#2563EB')
       .text('SEO Audit Report', 50, 200, { align: 'center' });
    
    // Website
    doc.fontSize(20)
       .fillColor('#000')
       .text(report.target, 50, 250, { align: 'center' });
    
    // Date
    doc.fontSize(14)
       .fillColor('#666')
       .text(`Generated on ${report.createdAt.toLocaleDateString()}`, 50, 290, { align: 'center' });
    
    // Company info
    doc.fontSize(12)
       .fillColor('#666')
       .text('Generated by WordGen SEO Audit System', 50, 650, { align: 'center' });
  }
  
  /**
   * Generate the summary page with overall metrics
   */
  private generateSummaryPage(doc: PDFKit.PDFDocument, report: SeoAuditReport): void {
    // Page title
    doc.fontSize(24)
       .fillColor('#2563EB')
       .text('Executive Summary', 50, 50);
    
    doc.moveDown(1);
    
    // Overall score
    doc.fontSize(16)
       .fillColor('#000')
       .text('Overall SEO Score:');
    
    // Score display
    this.drawScoreBar(doc, report.summary.onPageScore);
    
    doc.moveDown(2);
    
    // Key metrics
    doc.fontSize(16)
       .fillColor('#000')
       .text('Key Metrics:');
    
    doc.moveDown(1);
    
    const metrics = [
      { label: 'Pages Analyzed', value: report.summary.pagesAnalyzed },
      { label: 'Total Issues Found', value: report.summary.totalIssues },
      { label: 'Average Page Speed', value: `${report.summary.pageSpeed.average.toFixed(2)}ms` },
      { label: 'Broken Resources', value: report.summary.resourceStats.broken },
      { label: 'Broken Links', value: report.summary.linkStats.broken }
    ];
    
    metrics.forEach(metric => {
      doc.fontSize(12)
         .fillColor('#000')
         .text(`${metric.label}: ${metric.value}`, { continued: false });
      
      doc.moveDown(0.5);
    });
    
    doc.moveDown(2);
    
    // Issues by severity
    doc.fontSize(16)
       .fillColor('#000')
       .text('Issues by Severity:');
    
    doc.moveDown(1);
    
    // Draw chart for issues by severity
    this.drawIssuesChart(doc, report.summary.issuesBySeverity);
  }
  
  /**
   * Generate pages detailing all issues found
   */
  private generateIssuesPages(doc: PDFKit.PDFDocument, report: SeoAuditReport): void {
    // Page title
    doc.fontSize(24)
       .fillColor('#2563EB')
       .text('Detailed Issues', 50, 50);
    
    doc.moveDown(1);
    
    // Critical issues
    if (report.issues.critical.length > 0) {
      doc.fontSize(18)
         .fillColor('#DC2626')
         .text('Critical Issues');
      
      doc.moveDown(0.5);
      
      report.issues.critical.forEach((issue, index) => {
        this.renderIssue(doc, issue, index + 1);
        doc.moveDown(1);
      });
    }
    
    // Check if we need a new page for high issues
    if (doc.y > 650 && report.issues.high.length > 0) {
      doc.addPage();
    }
    
    // High issues
    if (report.issues.high.length > 0) {
      doc.fontSize(18)
         .fillColor('#EA580C')
         .text('High Priority Issues');
      
      doc.moveDown(0.5);
      
      report.issues.high.forEach((issue, index) => {
        this.renderIssue(doc, issue, index + 1);
        doc.moveDown(1);
      });
    }
    
    // Check if we need a new page for medium issues
    if (doc.y > 650 && report.issues.medium.length > 0) {
      doc.addPage();
    }
    
    // Medium issues
    if (report.issues.medium.length > 0) {
      doc.fontSize(18)
         .fillColor('#CA8A04')
         .text('Medium Priority Issues');
      
      doc.moveDown(0.5);
      
      report.issues.medium.forEach((issue, index) => {
        this.renderIssue(doc, issue, index + 1);
        doc.moveDown(1);
      });
    }
    
    // Check if we need a new page for low issues
    if (doc.y > 650 && report.issues.low.length > 0) {
      doc.addPage();
    }
    
    // Low issues
    if (report.issues.low.length > 0) {
      doc.fontSize(18)
         .fillColor('#65A30D')
         .text('Low Priority Issues');
      
      doc.moveDown(0.5);
      
      report.issues.low.forEach((issue, index) => {
        this.renderIssue(doc, issue, index + 1);
        doc.moveDown(1);
      });
    }
  }
  
  /**
   * Generate performance metrics page
   */
  private generatePerformancePage(doc: PDFKit.PDFDocument, report: SeoAuditReport): void {
    // Page title
    doc.fontSize(24)
       .fillColor('#2563EB')
       .text('Performance Analysis', 50, 50);
    
    doc.moveDown(1);
    
    // Page speed overview
    doc.fontSize(16)
       .fillColor('#000')
       .text('Page Speed Overview:');
    
    doc.moveDown(0.5);
    
    doc.fontSize(12)
       .fillColor('#666')
       .text(`Average: ${report.summary.pageSpeed.average.toFixed(2)}ms`);
    
    doc.fontSize(12)
       .fillColor('#666')
       .text(`Fastest: ${report.summary.pageSpeed.min.toFixed(2)}ms`);
    
    doc.fontSize(12)
       .fillColor('#666')
       .text(`Slowest: ${report.summary.pageSpeed.max.toFixed(2)}ms`);
    
    doc.moveDown(2);
    
    // Page speed scores
    doc.fontSize(16)
       .fillColor('#000')
       .text('Page Speed Scores:');
    
    doc.moveDown(0.5);
    
    // Get top 10 URLs by page speed score (lowest first)
    const pageSpeedEntries = Object.entries(report.performance.pageSpeedScores)
      .sort(([, scoreA], [, scoreB]) => scoreA - scoreB)
      .slice(0, 10);
    
    if (pageSpeedEntries.length > 0) {
      pageSpeedEntries.forEach(([url, score]) => {
        // URL (truncated if too long)
        const displayUrl = url.length > 60 ? url.substring(0, 57) + '...' : url;
        
        doc.fontSize(10)
           .fillColor('#000')
           .text(displayUrl, 50, doc.y, { width: 350 });
        
        // Score with color coding
        const scoreColor = score >= 90 ? '#65A30D' : (score >= 70 ? '#CA8A04' : '#DC2626');
        
        doc.fontSize(10)
           .fillColor(scoreColor)
           .text(`${score.toFixed(0)}`, 400, doc.y - 10);
        
        // Score bar
        this.drawSimpleBar(doc, score, 420, doc.y - 12, 120);
        
        doc.moveDown(0.5);
      });
    } else {
      doc.fontSize(12)
         .fillColor('#666')
         .text('No page speed data available');
    }
    
    doc.moveDown(2);
    
    // Resource sizes
    doc.fontSize(16)
       .fillColor('#000')
       .text('Resource Size by Page:');
    
    doc.moveDown(0.5);
    
    // Get top 10 URLs by resource size (largest first)
    const resourceSizeEntries = Object.entries(report.performance.resourceSizes)
      .sort(([, sizeA], [, sizeB]) => sizeB - sizeA)
      .slice(0, 10);
    
    if (resourceSizeEntries.length > 0) {
      resourceSizeEntries.forEach(([url, size]) => {
        // URL (truncated if too long)
        const displayUrl = url.length > 60 ? url.substring(0, 57) + '...' : url;
        
        doc.fontSize(10)
           .fillColor('#000')
           .text(displayUrl, 50, doc.y, { width: 350 });
        
        // Format size (KB or MB)
        const formattedSize = size > 1024 * 1024 
          ? `${(size / (1024 * 1024)).toFixed(2)} MB` 
          : `${(size / 1024).toFixed(2)} KB`;
        
        doc.fontSize(10)
           .fillColor('#000')
           .text(formattedSize, 400, doc.y - 10);
        
        doc.moveDown(0.5);
      });
    } else {
      doc.fontSize(12)
         .fillColor('#666')
         .text('No resource size data available');
    }
  }
  
  /**
   * Generate content analysis page
   */
  private generateContentPage(doc: PDFKit.PDFDocument, report: SeoAuditReport): void {
    // Page title
    doc.fontSize(24)
       .fillColor('#2563EB')
       .text('Content Analysis', 50, 50);
    
    doc.moveDown(1);
    
    // Word counts
    doc.fontSize(16)
       .fillColor('#000')
       .text('Word Count by Page:');
    
    doc.moveDown(0.5);
    
    // Get top 10 URLs by word count (largest first)
    const wordCountEntries = Object.entries(report.content.wordCounts)
      .sort(([, countA], [, countB]) => countB - countA)
      .slice(0, 10);
    
    if (wordCountEntries.length > 0) {
      wordCountEntries.forEach(([url, count]) => {
        // URL (truncated if too long)
        const displayUrl = url.length > 60 ? url.substring(0, 57) + '...' : url;
        
        doc.fontSize(10)
           .fillColor('#000')
           .text(displayUrl, 50, doc.y, { width: 350 });
        
        doc.fontSize(10)
           .fillColor('#000')
           .text(`${count.toLocaleString()} words`, 400, doc.y - 10);
        
        doc.moveDown(0.5);
      });
    } else {
      doc.fontSize(12)
         .fillColor('#666')
         .text('No word count data available');
    }
    
    doc.moveDown(2);
    
    // Missing metadata
    doc.fontSize(16)
       .fillColor('#000')
       .text('Pages with Missing Metadata:');
    
    doc.moveDown(0.5);
    
    if (report.content.missingMetadata.length > 0) {
      report.content.missingMetadata.slice(0, 10).forEach(({ url, missingElements }) => {
        // URL (truncated if too long)
        const displayUrl = url.length > 60 ? url.substring(0, 57) + '...' : url;
        
        doc.fontSize(10)
           .fillColor('#000')
           .text(displayUrl, 50, doc.y, { width: 350 });
        
        doc.fontSize(10)
           .fillColor('#DC2626')
           .text(`Missing: ${missingElements.join(', ')}`, 50, doc.y, { width: 490 });
        
        doc.moveDown(0.8);
      });
    } else {
      doc.fontSize(12)
         .fillColor('#666')
         .text('No pages with missing metadata');
    }
    
    doc.moveDown(2);
    
    // Duplicate content
    doc.fontSize(16)
       .fillColor('#000')
       .text('Duplicate Content:');
    
    doc.moveDown(0.5);
    
    if (report.content.duplicateContent.length > 0) {
      report.content.duplicateContent.slice(0, 5).forEach(({ pages, similarityScore }) => {
        doc.fontSize(12)
           .fillColor('#000')
           .text(`Similarity: ${(similarityScore * 100).toFixed(0)}%`);
        
        doc.moveDown(0.3);
        
        pages.slice(0, 3).forEach(url => {
          const displayUrl = url.length > 60 ? url.substring(0, 57) + '...' : url;
          
          doc.fontSize(10)
             .fillColor('#666')
             .text(`- ${displayUrl}`);
        });
        
        if (pages.length > 3) {
          doc.fontSize(10)
             .fillColor('#666')
             .text(`... and ${pages.length - 3} more pages`);
        }
        
        doc.moveDown(0.8);
      });
    } else {
      doc.fontSize(12)
         .fillColor('#666')
         .text('No duplicate content detected');
    }
  }
  
  /**
   * Render a single issue
   */
  private renderIssue(doc: PDFKit.PDFDocument, issue: SeoIssue, index: number): void {
    doc.fontSize(14)
       .fillColor('#000')
       .text(`${index}. ${issue.type}`, { continued: false });
    
    doc.fontSize(12)
       .fillColor('#666')
       .text(issue.description, { continued: false });
    
    doc.moveDown(0.5);
    
    // Affected URLs (limit to 3 for space)
    if (issue.affectedUrls.length > 0) {
      doc.fontSize(10)
         .fillColor('#000')
         .text('Affected URLs:', { continued: false });
      
      issue.affectedUrls.slice(0, 3).forEach(url => {
        const displayUrl = url.length > 60 ? url.substring(0, 57) + '...' : url;
        
        doc.fontSize(9)
           .fillColor('#666')
           .text(`- ${displayUrl}`, { continued: false });
      });
      
      if (issue.affectedUrls.length > 3) {
        doc.fontSize(9)
           .fillColor('#666')
           .text(`... and ${issue.affectedUrls.length - 3} more`, { continued: false });
      }
    }
    
    doc.moveDown(0.5);
    
    // Recommendations
    if (issue.recommendations.length > 0) {
      doc.fontSize(10)
         .fillColor('#000')
         .text('Recommendations:', { continued: false });
      
      issue.recommendations.forEach(recommendation => {
        doc.fontSize(9)
           .fillColor('#666')
           .text(`• ${recommendation}`, { continued: false });
      });
    }
  }
  
  /**
   * Draw a score bar with color gradient
   */
  private drawScoreBar(doc: PDFKit.PDFDocument, score: number): void {
    const x = 50;
    const y = doc.y + 10;
    const width = 500;
    const height = 30;
    
    // Draw background
    doc.rect(x, y, width, height)
       .fill('#E5E7EB');
    
    // Calculate filled width
    const filledWidth = (score / 100) * width;
    
    // Determine color based on score
    let fillColor;
    if (score >= 80) fillColor = '#65A30D'; // green
    else if (score >= 60) fillColor = '#CA8A04'; // yellow
    else if (score >= 40) fillColor = '#EA580C'; // orange
    else fillColor = '#DC2626'; // red
    
    // Draw filled portion
    doc.rect(x, y, filledWidth, height)
       .fill(fillColor);
    
    // Draw score text
    doc.fontSize(16)
       .fillColor('#FFFFFF')
       .text(`${Math.round(score)}`, x + filledWidth - 30, y + 7);
  }
  
  /**
   * Draw a simple bar for metrics
   */
  private drawSimpleBar(doc: PDFKit.PDFDocument, value: number, x: number, y: number, width: number): void {
    const height = 10;
    
    // Draw background
    doc.rect(x, y, width, height)
       .fill('#E5E7EB');
    
    // Calculate filled width (max 100%)
    const filledWidth = Math.min(1, value / 100) * width;
    
    // Determine color based on value
    let fillColor;
    if (value >= 80) fillColor = '#65A30D'; // green
    else if (value >= 60) fillColor = '#CA8A04'; // yellow
    else if (value >= 40) fillColor = '#EA580C'; // orange
    else fillColor = '#DC2626'; // red
    
    // Draw filled portion
    doc.rect(x, y, filledWidth, height)
       .fill(fillColor);
  }
  
  /**
   * Draw issues chart by severity
   */
  private drawIssuesChart(doc: PDFKit.PDFDocument, issues: SeoAuditReport['summary']['issuesBySeverity']): void {
    const startX = 100;
    const startY = doc.y + 10;
    const barHeight = 20;
    const barSpacing = 30;
    const maxWidth = 400;
    
    // Calculate total for percentage calculation
    const total = issues.critical + issues.high + issues.medium + issues.low + issues.info;
    
    // Draw each bar
    this.drawIssueSeverityBar(doc, 'Critical', issues.critical, total, startX, startY, maxWidth, barHeight, '#DC2626');
    this.drawIssueSeverityBar(doc, 'High', issues.high, total, startX, startY + barSpacing, maxWidth, barHeight, '#EA580C');
    this.drawIssueSeverityBar(doc, 'Medium', issues.medium, total, startX, startY + barSpacing * 2, maxWidth, barHeight, '#CA8A04');
    this.drawIssueSeverityBar(doc, 'Low', issues.low, total, startX, startY + barSpacing * 3, maxWidth, barHeight, '#65A30D');
    
    // Update Y position
    doc.y = startY + barSpacing * 4;
  }
  
  /**
   * Draw a single bar for issue severity
   */
  private drawIssueSeverityBar(
    doc: PDFKit.PDFDocument, 
    label: string, 
    value: number, 
    total: number, 
    x: number, 
    y: number, 
    maxWidth: number, 
    height: number, 
    color: string
  ): void {
    // Draw label
    doc.fontSize(10)
       .fillColor('#000')
       .text(label, x - 50, y + 5);
    
    // Draw background
    doc.rect(x, y, maxWidth, height)
       .fill('#E5E7EB');
    
    // Calculate width based on percentage of total
    const percentage = total > 0 ? (value / total) : 0;
    const width = maxWidth * percentage;
    
    // Draw bar
    if (width > 0) {
      doc.rect(x, y, width, height)
         .fill(color);
    }
    
    // Draw value and percentage
    const percentText = total > 0 ? ` (${Math.round(percentage * 100)}%)` : '';
    doc.fontSize(10)
       .fillColor(value > 0 ? '#FFF' : '#000')
       .text(`${value}${percentText}`, x + 5, y + 5);
  }
}

// Export singleton instance
export const pdfGenerator = new PdfGeneratorService(); 